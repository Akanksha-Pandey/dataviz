```{r echo = FALSE, message = FALSE}
# run setup script
source("_common.R")

library(lubridate)
library(ggridges)
```


# Redundant coding {#redundant-coding}

At the end of Chapter \@ref(color-pitfalls), I argued that even if colors are visually distinct in principle, this distinction can disappear when the colored elements are small. To demonstrate this effect on an actual figure, I have drawn Figure \@ref(fig:iris-scatter-one-shape), which uses the first three colors from the Okabe-Ito color scale (Figure \@ref(fig:palette-Okabe-Ito)). The *virginica* points in green and the *versicolor* points in blue blend into each other (Figure \@ref(fig:iris-scatter-one-shape)), even though the two colors are clearly distinct in principle.

(ref:iris-scatter-one-shape) Sepal width versus sepal length for three different iris species (*Iris setosa*, *Iris virginica*, and *Iris versicolor*). Each point represents the measurements for one plant sample. A small amount of jitter has been applied to all point positions to prevent overplotting. The figure is labeled bad because the *virginica* points in green and the *versicolor* points in blue are difficult to distinguish from each other.

```{r iris-scatter-one-shape, fig.cap = '(ref:iris-scatter-one-shape)'}
iris_scatter_base <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, fill = Species, color = Species)) + 
    scale_color_manual(values = darken(c("#E69F00", "#56B4E9", "#009E73"), 0.3),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_fill_manual(values = c("#E69F0080", "#56B4E980", "#009E7380"),
                      breaks = c("setosa", "virginica", "versicolor"),
                      name = "species") +
    scale_x_continuous(limits = c(3.95, 8.2), expand = c(0, 0),
                       labels = c("4.0", "5.0", "6.0", "7.0", "8.0"),
                       name = "sepal length") +
    scale_y_continuous(limits = c(1.9, 4.6), expand = c(0, 0),
                       name = "sepal width") +
    theme_minimal_grid()

iris_scatter <- iris_scatter_base +
                  geom_point(size=2.5, shape=21,
                             position = position_jitter(width = 0.01 * diff(range(iris$Sepal.Length)),
                                          height = 0.01 * diff(range(iris$Sepal.Width)),
                                          seed = 3942)) +
                  theme_minimal_grid()


stamp_bad(iris_scatter)
```

Surprisingly, the green and blue points look more distinct for people with red--green color-vision-deficiency (deuteranomaly or protanomaly) than for people with normal color vision (compare Figure \@ref(fig:iris-scatter-one-shape-cvd), top row to Figure \@ref(fig:iris-scatter-one-shape)). On the other hand, for people with blue--yellow deficiency (tritanomaly) the blue and green points look very similar (Figure \@ref(fig:iris-scatter-one-shape-cvd), bottom left). And, if we print out the figure in gray-scale (i.e., we *desaturate* the figure), we cannot distinguish any of the iris species (Figure \@ref(fig:iris-scatter-one-shape-cvd), bottom right).

(ref:iris-scatter-one-shape-cvd) Color-vision-deficiency simulation of Figure \@ref(fig:iris-scatter-one-shape).

```{r iris-scatter-one-shape-cvd, fig.width = 8.5, fig.asp = 0.65, fig.cap = '(ref:iris-scatter-one-shape-cvd)'}
iris_scatter_small <- iris_scatter_base +
                        geom_point(size=2., shape=21,
                           position = position_jitter(width = 0.01 * diff(range(iris$Sepal.Length)),
                                          height = 0.01 * diff(range(iris$Sepal.Width)),
                                          seed = 3942)) +
                        theme_minimal_grid(12) + theme(plot.margin = margin(24, 6, 6, 6))


cvd_sim2(iris_scatter_small,
         scale = 1, label_x = 0.03)
```

There are two simple improvements we can make to Figure \@ref(fig:iris-scatter-one-shape) to alleviate these issues. First, we can swap the colors used for *setosa* and *versicolor*, so that the blue is no longer directly next to the green (Figure \@ref(fig:iris-scatter-three-shapes)). Second, we can use three different symbol shapes, so that the points don't all look the same. With these two changes, both the original version of the plot (Figure \@ref(fig:iris-scatter-three-shapes)) and the versions under color-vision-deficiency and in grayscale (Figure \@ref(fig:iris-scatter-three-shapes-cvd)) become legible.

(ref:iris-scatter-three-shapes) Sepal width versus sepal length for three different iris species. Compared to Figure \@ref(fig:iris-scatter-one-shape), we have swapped the colors for *Iris setosa* and *Iris versicolor* and we have given each iris species its own point shape.

```{r iris-scatter-three-shapes, fig.cap = '(ref:iris-scatter-three-shapes)'}
iris_scatter2_base <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, shape = Species, fill = Species, color = Species)) +     scale_shape_manual(values = c(21, 22, 23),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_color_manual(values = darken(c("#56B4E9", "#E69F00", "#009E73"), 0.3),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_fill_manual(values = c("#56B4E980", "#E69F0080", "#009E7380"),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_x_continuous(limits = c(3.95, 8.2), expand = c(0, 0),
                       labels = c("4.0", "5.0", "6.0", "7.0", "8.0"),
                       name = "sepal length") +
    scale_y_continuous(limits = c(1.9, 4.6), expand = c(0, 0),
                       name = "sepal width")

iris_scatter2 <- iris_scatter2_base +
                  geom_point(size=2.5,
                             position = position_jitter(width = 0.01 * diff(range(iris$Sepal.Length)),
                                          height = 0.01 * diff(range(iris$Sepal.Width)),
                                          seed = 3942)) +
                  theme_minimal_grid()

stamp_phantom(iris_scatter2)
```


(ref:iris-scatter-three-shapes-cvd) Color-vision-deficiency simulation of Figure \@ref(fig:iris-scatter-three-shapes). Because of the use of different point shapes, even the fully desaturated gray-scale version of the plot is legible.

```{r iris-scatter-three-shapes-cvd, fig.width = 8.5, fig.asp = 0.65, fig.cap = '(ref:iris-scatter-three-shapes-cvd)'}
iris_scatter2_small <- iris_scatter2_base +
                        geom_point(size=2.,
                           position = position_jitter(width = 0.01 * diff(range(iris$Sepal.Length)),
                                          height = 0.01 * diff(range(iris$Sepal.Width)),
                                          seed = 3942)) +
                        theme_minimal_grid(12) + theme(plot.margin = margin(24, 6, 6, 6))


cvd_sim2(iris_scatter2_small,
         scale = 1, label_x = 0.03)
```

**Now some text here to describe the general concept of redundant coding, what is it, why do we do it.**


(ref:iris-scatter-with-ellipses) Sepal width versus sepal length for three different iris species.

```{r iris-scatter-with-ellipses, fig.width = 4.6, fig.asp = 0.8, fig.cap = '(ref:iris-scatter-with-ellipses)'}
label_df <- data.frame(Species = c("setosa", "virginica", "versicolor"),
                     Sepal.Width = c(4.2, 3.76, 2.08),
                     Sepal.Length = c(5.7, 7, 5.1),
                     hjust = c(0, 0.5, 0),
                     vjust = c(0, 0.5, 1))

iris_scatter3 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, shape = Species, fill = Species, color = Species)) + 
    geom_point(size = 2.5,
               position = position_jitter(width = 0.01 * diff(range(iris$Sepal.Length)),
                                          height = 0.01 * diff(range(iris$Sepal.Width)),
                                          seed = 3942)) +
    stat_ellipse(size = 0.5) +
    geom_text(data = label_df,
              aes(label = Species, hjust = hjust, vjust = vjust),
              size = 14/.pt) +
    scale_shape_manual(values = c(21, 22, 23),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_fill_manual(values = c("#56B4E980", "#E69F0080", "#009E7380"),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    scale_color_manual(values = darken(c("#56B4E9", "#E69F00", "#009E73"), 0.3),
                       breaks = c("setosa", "virginica", "versicolor"),
                       name = "species") +
    guides(fill = "none", color = "none", shape = "none") +
    scale_x_continuous(limits = c(3.95, 8.2), expand = c(0, 0),
                       labels = c("4.0", "5.0", "6.0", "7.0", "8.0"),
                       name = "sepal length") +
    scale_y_continuous(limits = c(1.9, 4.6), expand = c(0, 0),
                       name = "sepal width") +
    theme_half_open()

iris_scatter3
```


I have removed the background grid from this figure because otherwise the figure was becoming too busy.

```{block type='rmdtip', echo=TRUE}
Whenever possible, design your figures so they don't need a legend.
```


Let's consider another example that also demonstrates a very common visualization mistake.

(ref:tech-stocks-bad-legend) Stock price over time for four major tech companies. The stock price for each company has been normalized to equal 100 in June 2012.

```{r tech-stocks-bad-legend, fig.cap = '(ref:tech-stocks-bad-legend)'}
price_plot_base <- ggplot(tech_stocks, aes(x=date, y=price_indexed, color=ticker)) +
  geom_line() +
  scale_color_manual(values=c("#000000", "#E69F00", "#56B4E9", "#009E73"),
                     name="",
                     breaks=c("GOOG", "AAPL", "FB", "MSFT"),
                     labels=c("Alphabet", "Apple", "Facebook", "Microsoft")) +
  scale_x_date(name="year",
               limits=c(ymd("2012-06-01"), ymd("2017-05-31")),
               expand=c(0,0)) + 
  scale_y_continuous(name="stock price, indexed",
                     limits = c(0, 560),
                     expand=c(0,0))

stamp_bad(price_plot_base + theme_minimal_hgrid())
```

(ref:tech-stocks-bad-legend-cvd) Color-vision-deficiency simulation of Figure \@ref(fig:tech-stocks-bad-legend).

```{r tech-stocks-bad-legend-cvd, fig.width = 8.5, fig.asp = 0.6, fig.cap = '(ref:tech-stocks-bad-legend-cvd)'}
cvd_sim2(price_plot_base + theme_minimal_hgrid(12) + theme(plot.margin = margin(18, 6, 6, 6)),
         scale = 1, label_x = 0.03)
```


The figure contains four lines, representing the stock prices of four different companies. The lines are color coded using a colorblind-friendly color scale. So it should be relatively straightfoward to associate each line with the corresponding company. Yet it is not. The problem here is that the data lines have a clear visual order. The yellow line, representing Facebook, is clearly the highest line, and the black line, representing Apple, is clearly the lowest, with Alphabet and Microsoft inbetween, in that order. Yet the order of the four companies in the legend is Alphabet, Apple, Facebook, Microsoft (alphabetic order). Thus, the perceived order of the data lines differs from the order of the companies in the legend, and it takes a surprising amount of effort to match data lines with company names.

This problem arises commonly with plotting software that autogenerates legends, as is the case for instance with R's ggplot2. The plotting software has no concept of the visual order that the viewer will perceive in the data, and it will instead sort the legend by some other order, most commonly alphabetical. We can fix this problem by manually reordering the entries in the legend so they match the preceived ordering in the data.

(ref:tech-stocks-good-legend) Stock price over time for four major tech companies. The stock price for each company has been normalized to equal 100 in June 2012.

```{r tech-stocks-good-legend, fig.cap = '(ref:tech-stocks-good-legend)'}
price_plot <- ggplot(tech_stocks, aes(x=date, y=price_indexed, color=ticker)) +
  geom_line() +
  scale_color_manual(values=c("#000000", "#E69F00", "#56B4E9", "#009E73"),
                     name="",
                     breaks=c("FB", "GOOG", "MSFT", "AAPL"),
                     labels=c("Facebook", "Alphabet", "Microsoft", "Apple")) +
  scale_x_date(name="year",
               limits=c(ymd("2012-06-01"), ymd("2017-05-31")),
               expand=c(0,0)) + 
  scale_y_continuous(name="stock price, indexed",
                     limits = c(0, 560),
                     expand=c(0,0)) +
  theme_minimal_hgrid()


stamp_phantom(price_plot)
```

While the above figure is a major improvement, we can still do better. Even with the correct ordering, a legend imposes an unnecessary mental burden on the viewer of the figure. The viewer has to match the colors in the legend to the colors in the figure and translate which company name goes with which data line. It is better to get rid of the legend altogether and instead draw the company names right next to the data lines.

(ref:tech-stocks-good-no-legend) Stock price over time for four major tech companies. The stock price for each company has been normalized to equal 100 in June 2012.

```{r tech-stocks-good-no-legend, fig.cap = '(ref:tech-stocks-good-no-legend)'}
yann <- axis_canvas(price_plot, axis = "y") +
  geom_text(data = filter(tech_stocks, date == "2017-06-02"),
            aes(y = price_indexed, label = paste0(" ", company)),
            x = 0, hjust = 0, size = 12/.pt)

price_plot_ann <- insert_yaxis_grob(price_plot + theme(legend.position = "none"), yann,
                                    width = grid::unit(0.3, "null"))
stamp_phantom(price_plot_ann)
```

I'll provide a few more examples. First, in a density plot we may want to label the density curves directly rather than adding a color legend.
```{r}
# compute densities for sepal lengths
iris_dens <- group_by(iris, Species) %>%
  do(ggplot2:::compute_density(.$Sepal.Length, NULL)) %>%
  rename(Sepal.Length = x)

# get the maximum values
iris_max <- filter(iris_dens, density == max(density)) %>%
  ungroup() %>%
  mutate(hjust = c(0, 0.4, 0),
         vjust = c(1, 0, 1),
         nudge_x = c(0.11, 0, 0.2),
         nudge_y = c(-0.02, 0.02, -0.02) 
        )

iris_p <- ggplot(iris_dens, aes(x = Sepal.Length, y = density, fill = Species, color = Species)) + 
  geom_density_line(stat = "identity") +
  geom_text(data = iris_max, aes(label = Species, hjust = hjust, vjust = vjust,
                                 x = Sepal.Length + nudge_x, 
                                 y = density + nudge_y), 
            size = 12/.pt,
            inherit.aes = FALSE) +
  scale_color_manual(values = darken(c("#56B4E9", "#E69F00", "#009E73"), 0.3),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none") +
  scale_fill_manual(values = c("#56B4E980", "#E69F0080", "#009E7380"),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none") +
  scale_x_continuous(expand = c(0, 0), name = "sepal length") +
  scale_y_continuous(limits = c(0, 1.5), expand = c(0, 0)) +
  theme_minimal_hgrid()
  
stamp_phantom(plot_grid(iris_p, NULL, rel_widths = c(8, 1)))
```

Second, we can also combine this concept with the scatter plot from the beginning of this chapter to avoid a legend in that plot.

```{r fig.asp=0.75}
# compute densities for sepal lengths
iris_dens2 <- group_by(iris, Species) %>%
  do(ggplot2:::compute_density(.$Sepal.Width, NULL)) %>%
  rename(Sepal.Width = x)

# we need different hjust and nudge values here
iris_max <- mutate(iris_max,
         hjust = c(1, 0.4, 0),
         vjust = c(1, 0, 1),
         nudge_x = c(-0.18, 0, 0.43),
         nudge_y = c(-0.02, 0.05, -0.02) 
        )


xdens <- axis_canvas(iris_scatter2, axis = "x") +
  geom_density_line(data=iris_dens, aes(x = Sepal.Length, y = density, fill = Species, color = Species),
                    stat = "identity", size = .2) +
  geom_text(data = iris_max, aes(label = Species, hjust = hjust, vjust = vjust,
                                 x = Sepal.Length + nudge_x, 
                                 y = density + nudge_y),
            size = 11/.pt, color = "black", inherit.aes = FALSE) +
  scale_color_manual(values = darken(c("#56B4E9", "#E69F00", "#009E73"), 0.3),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none") +
  scale_fill_manual(values = c("#56B4E980", "#E69F0080", "#009E7380"),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none")

ydens <- axis_canvas(iris_scatter2, axis = "y", coord_flip = TRUE) +
  geom_density_line(data = iris_dens2, aes(x = Sepal.Width, y = density, fill = Species, color = Species),
                    stat = "identity", alpha = 0.5, size = .2)  +
  scale_color_manual(values = darken(c("#56B4E9", "#E69F00", "#009E73"), 0.3),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none") +
  scale_fill_manual(values = c("#56B4E980", "#E69F0080", "#009E7380"),
                    breaks = c("virginica", "versicolor", "setosa"),
                    guide = "none") +
  coord_flip()

p1 <- insert_xaxis_grob(iris_scatter2 + 
                          theme(legend.position = "none"),
                        xdens, grid::unit(.2, "null"), position = "top")
p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.15, "null"), position = "right")
stamp_phantom(plot_grid(p2, NULL, rel_widths = c(8, 1)))
```


And finally, Figure \@ref(fig:temp-ridgeline-colorbar) shows a case where a color bar representing temperature is integrated into the temperature axis.


(ref:temp-ridgeline-colorbar) Temperatures in Lincoln, Nebraska, in 2016. This figure is a variation of Figure \@ref(fig:temp-ridgeline). Temperature is now shown both by location along the *x* axis and by color, and a color bar along the *x* axis visualizes the scale that converts temperatures into colors.

```{r temp-ridgeline-colorbar, fig.asp = 0.652, fig.cap = '(ref:temp-ridgeline-colorbar)'}
bandwidth <- 3.4

lincoln_base <- ggplot(lincoln_weather, aes(x = `Mean Temperature [F]`, y = `Month`, fill = ..x..)) +
  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01, bandwidth = bandwidth,
                               color = "black", size = 0.25) +
  scale_x_continuous(expand = c(0, 0), breaks = c(0, 25, 50, 75), labels = NULL) +
  scale_y_discrete(expand = c(0, .2, 0, 2.6)) +
  scale_fill_continuous_sequential(palette = "Heat", l1 = 20, l2 = 100, c2 = 0) +
  xlab("mean temperature (°F)") +
  guides(fill = "none") +
  theme_ridges(center = TRUE, grid = TRUE) +
  theme(axis.title.y = element_blank())

# x axis labels
temps <- data.frame(temp = c(0, 25, 50, 75))

# calculate corrected color ranges
# stat_joy uses the +/- 3*bandwidth calculation internally
tmin <- min(lincoln_weather$`Mean Temperature [F]`) - 3*bandwidth
tmax <- max(lincoln_weather$`Mean Temperature [F]`) + 3*bandwidth

xax <- axis_canvas(lincoln_base, axis = "x", ylim = c(0, 2)) +
  geom_ridgeline_gradient(data = data.frame(temp = seq(tmin, tmax, length.out = 100)),
                          aes(x = temp, y = 1.1, height = .9, fill = temp),
                          color = "transparent") +
  geom_text(data = temps, aes(x = temp, label = temp),
            color = "black",
            y = 0.9, hjust = 0.5, vjust = 1, size = 14/.pt) +
  scale_fill_continuous_sequential(palette = "Heat", l1 = 20, l2 = 100, c2 = 0)

lincoln_final <- insert_xaxis_grob(lincoln_base, xax, position = "bottom", height = unit(0.1, "null"))

ggdraw(lincoln_final)
```
