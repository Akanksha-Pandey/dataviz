```{r echo = FALSE, message = FALSE}
# run setup script
source("_common.R")

library(dplyr)
library(stringr)
library(lubridate)
library(viridis)
```

# Handling overlapping points {#overlapping-points}

When we want to visualize large or very large datasets, we often experience the challenge that simple *x*--*y* scatter plots do not work very well because many points lie on top of each other and partially or fully overlap. And similar problems can arise even in small datasets if values were recorded with low precision or rounded, such that multiple observations have exactly the same numeric values. The technical term commonly used to describe this situation is "overplotting", i.e., plotting many points on top of each other. Below, I describe several strategies you can pursue when you encounter this challenge.

## Partial transparency and jittering

Consider Figure \@ref(fig:mpg-cty-displ-solid): **some more text here. explain the problem: points overlapp, though it can't be seen in the figure.**

(ref:mpg-cty-displ-solid) Fuel economy versus engine displacement, for popular cars released between 1999 and 2008. Each point represents one car. The point color encodes the drive train: front-wheel drive (FWD), rear-wheel drive (RWD), or four-wheel drive (4WD). The figure is labeled "bad" because many points overlap and obscure each other. 

```{r mpg-cty-displ-solid, fig.width=5.5, fig.asp=.7416, fig.cap='(ref:mpg-cty-displ-solid)'}
p_mpg_solid <- ggplot(mpg, aes(y = cty, x = displ, color = drv, fill = drv)) +
  geom_point(size = 3, shape = 21) + 
  ylab("fuel economy (mpg)") +
  xlab("displacement (l)") +
  scale_color_manual(values=c("#202020", "#E69F00", "#56B4E9"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  scale_fill_manual(values=c("#202020", "#E69F00", "#56B4E9"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  theme_half_open() +
  theme(legend.position = c(.7, .8))

stamp_bad(p_mpg_solid)
```



A simple way to ameliorate this issue is to use partial transparency.


(ref:mpg-cty-displ-transp) Fuel economy versus engine displacement. Because points have been made partially transparent, we can now see points that are plotted on top of each other as points with darker shade.

```{r mpg-cty-displ-transp, fig.width=5.5, fig.asp=.7416, fig.cap='(ref:mpg-cty-displ-transp)'}
p_mpg_transp <- ggplot(mpg, aes(y = cty, x = displ, color = drv, fill = drv)) +
  geom_point(size = 3, shape = 21) + 
  ylab("fuel economy (mpg)") +
  xlab("displacement (l)") +
  scale_color_manual(values=c("#202020", "#E69F00", "#56B4E9"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  scale_fill_manual(values=c("#202020A6", "#E69F00A6", "#56B4E9A6"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  theme_half_open() +
  theme(legend.position = c(.7, .8))

stamp_phantom(p_mpg_transp)
```


Making points partially transparent is not always sufficient. For example, the same dataset contains fuel economy for both city and highway driving. If we plot those two quantities against each other, we obtain the following figure.

Because fuel economy is rounded to whole integers in this dataset, many points lie exactly on top of each other. While these fully overlapping points appear darker in the plot, the visual appearance is that of one darker point rather than of a set of points plotted in the same location. We can emphasize the number of points in the same locations by applying a small amount of jitter, i.e., displacing each point randomly by a small amount.

(ref:mpg-cty-displ-jitter) Fuel economy versus engine displacement. By adding a small amount of jitter to each point, we can make the overlapping points more clearly visible without substantially distorting the message of the plot.

```{r mpg-cty-displ-jitter, fig.width=5.5, fig.asp=.7416, fig.cap='(ref:mpg-cty-displ-jitter)'}
p_mpg_jitter <- ggplot(mpg, aes(y = cty, x = displ, color = drv, fill = drv)) +
  geom_point(size = 3, shape = 21,
             position = position_jitter(width = 0.01 * diff(range(mpg$displ)),
                                        height = 0.01 * diff(range(mpg$cty)))) + 
  ylab("fuel economy (mpg)") +
  xlab("displacement (l)") +
  scale_color_manual(values=c("#202020", "#E69F00", "#56B4E9"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  scale_fill_manual(values=c("#202020A6", "#E69F00A6", "#56B4E9A6"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  theme_half_open() +
  theme(legend.position = c(.7, .8))

stamp_phantom(p_mpg_jitter)
```


However, when jittering we have to make sure not to overdo it. If we jitter too much, we end up placing points in locations that are not representative of the underlying dataset and hence are creating a misleading visualization of the data.

(ref:mpg-cty-displ-jitter-extreme) Fuel economy versus engine displacement. It is critical not to add excessive amounts of jitter.

```{r mpg-cty-hwy-jitter-extreme, fig.width=5.5, fig.asp=.7416, fig.cap='(ref:mpg-cty-displ-jitter-extreme)'}
p_mpg_jitter_extreme <- ggplot(mpg, aes(y = cty, x = displ, color = drv, fill = drv)) +
  geom_point(size = 3, shape = 21,
             position = position_jitter(width = 0.1 * diff(range(mpg$displ)),
                                        height = 0.1 * diff(range(mpg$cty)))) + 
  ylab("fuel economy (mpg)") +
  xlab("displacement (l)") +
  scale_color_manual(values=c("#202020", "#E69F00", "#56B4E9"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  scale_fill_manual(values=c("#202020A6", "#E69F00A6", "#56B4E9A6"), 
                     name="drive train",
                     breaks=c("f", "r", "4"),
                     labels=c("FWD", "RWD", "4WD")) +
  theme_half_open() +
  theme(legend.position = c(.7, .8))

stamp_bad(p_mpg_jitter_extreme)
```

For example, in this particular case the extreme jittering creates the impression that for some cars the highway economy can fall below the city economy. However, such cases do not exist in the original dataset.

## Contour lines

When the number of points grows large, it can be helpful to indicate the point density, for example with contour lines. This technique works well for the following figure, which shows the total population as a function of area for counties in the midwest.
```{r midwest-density-dots, fig.asp = 0.8}
library(openintro) # for countyComplete dataset
midwest_states = c("Illinois", "Indiana", "Iowa", "Michigan", "Minnesota", "Missouri", "Ohio", "Wisconsin")

countyComplete %>% filter(state %in% midwest_states) -> county_midwest

p6 <- ggplot(county_midwest, aes(area, pop2010)) + 
  stat_density_2d(aes(fill = ..level..), geom = "polygon", color = "black", size = 0.2, alpha = 0.5) + 
  geom_point(color = "navy", size = .6, alpha = .7) + 
  scale_fill_gradient(low = "grey70", high = "grey30", guide = "none") +
  scale_y_log10(breaks = c(1000, 1e4, 1e5, 1e6, 1e7),
                limits = c(1000, 1e7),
                labels = c(expression(10^3), expression(10^4), expression(10^5),
                           expression(10^6), expression(10^7))) +
  scale_x_log10(breaks = c(100, 300, 1000, 3000),
                limits = c(50, 7000), expand = c(0, 0)) +
  ylab("population total") +
  xlab("area (square miles)") +
  theme_minimal_grid()
  
stamp_phantom(p6)
```

If we want to emphasize the overall features of the distribution rather than the individual points, we can also show only the contour lines and leave out the individual points.
```{r midwest-density-only, fig.asp = 0.8}
p7 <- ggplot(county_midwest, aes(area, pop2010)) + 
  stat_density_2d(aes(fill = ..level..), geom = "polygon", color = "black", size = 0.2, alpha = 0.5) + 
#  geom_point(color = "navy", size = 1, alpha = .7) + 
  scale_fill_gradient(low = "grey70", high = "grey30", guide = "none") +
  scale_y_log10(breaks = c(1000, 1e4, 1e5, 1e6, 1e7),
                limits = c(1000, 1e6),
                labels = c(expression(10^3), expression(10^4), expression(10^5),
                           expression(10^6), expression(10^7))) +
  scale_x_log10(breaks = c(100, 300, 1000, 3000),
                limits = c(150, 2000), expand = c(0, 0)) +
  ylab("population total") +
  xlab("area (square miles)") +
  theme_minimal_grid()
  
stamp_phantom(p7)
```

Finally, we can add a smoothing line to highlight the overall trend in the relationship between the two variables.
```{r midwest-density-smooth, fig.asp = 0.8}
p8 <- p7 + geom_smooth(color = "navy", se = FALSE)

stamp_phantom(p8)
```

## 2d histograms

None of the techniques discussed so far work very well when the majority of points falls into a small area relative to the overall extent of the data and the overall extent highlights important data features.

Consider the following figure, which shows the departure delay in minutes versus the flight departure time, for all flights departing Newark airport (EWR) in 2013.

```{r nycflights-points, fig.asp = 0.75}
library(nycflights13)

flights %>% filter(origin == "EWR") %>%
  mutate(`departure time` = hm(sprintf("%02d:%02d", dep_time %/% 100, dep_time %% 100 ))) %>%
  select(`departure time`, `departure delay (minutes)` = dep_delay) %>%
  na.omit() -> delay_df

# the break points along the x axis
breaks_x <- c("0:00", "6:00", "12:00", "18:00", "24:00")

p_flights_base <- ggplot(delay_df, aes(`departure time`, `departure delay (minutes)`)) + 
  geom_abline(slope = 0, intercept = 0, color="grey80") +
  scale_x_time(breaks = hm(breaks_x),
               labels = breaks_x) +
  theme_half_open()
  
p9 <- p_flights_base + geom_point(alpha = 0.2)

stamp_bad(p9)
```
Even though we have made the points fairly transparent, the majority of the points just form a black band between 0 and 300 minutes departure delay. This black band obscures whether most flights depart approximately on time or with substantial delay (say 50 minutes or more). At the same time, the most delayed flights (with delays of 400 minutes or more) are barely visible due to the transparency of the points.

A good solution for this particular case is a 2d histogram, where we subdivide the entire x--y plane into small squares, count how many observations fall into each square, and then color the square by that count. The result is the following figure.

```{r nycflights-2d-bins, fig.asp = 0.75}
p10 <- p_flights_base +
  geom_bin2d(bins=50) +
  scale_fill_continuous_sequential(palette = "Blue-Yellow", l2 = 90, c2 = 20) +
  theme(legend.position = c(0.85, .85))
stamp_phantom(p10)
```

This figure clearly highlights several important features. First, the vast majority of departures during the day (6am to about 9pm) actually depart without delay or even early (negative delay). However, a modest number of departures has a substantial delay. Moreover, the later a plane departs in the day the more of a delay it can have. Importantly, here the departure time is the actual time of departure, not the scheduled time of departure. So this figure does not necessarily tell us that planes scheduled to depart early never experience delay. What it does tell us, though, is that if a plane departs early it either has little delay or, in very rare cases, a delay of around 900 minutes.

As an alternative to binning the data into squares, we can also bin into hexagons. This approach, first proposed by 
@Carr-et-al-1987, has the advantage that the points in a hexagon are, on average, closer to the hexagon center than the points in an equal-area square are to the center of the square. As a consequence, the colored hexagon represents the data slightly more accurately than the colored square does. The following figure shows the same data with hexagon binning rather than square binning.

```{r nycflights-hex-bins, fig.asp = 0.75}
p11 <- p_flights_base +
  geom_hex(bins=50) +
  scale_fill_continuous_sequential(palette = "Blue-Yellow", l2 = 90, c2 = 20) +
  theme(legend.position = c(0.85, .85))
stamp_phantom(p11)
```

